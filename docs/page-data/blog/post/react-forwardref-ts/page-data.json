{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/blog/post/react-forwardref-ts","result":{"data":{"tags":{"edges":[{"node":{"path":"/blog/tag/gatsby"}},{"node":{"path":"/blog/tag/blog"}},{"node":{"path":"/blog/tag/php"}},{"node":{"path":"/blog/tag/symfony"}},{"node":{"path":"/blog/tag/pitch"}},{"node":{"path":"/blog/tag/react"}},{"node":{"path":"/blog/tag/testing"}},{"node":{"path":"/blog/tag/typescript"}}]},"site":{"siteMetadata":{"author":{"twitter":"ph_fritsche"}}},"mdx":{"body":"var _excluded = [\"components\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar _frontmatter = {\n  \"title\": \"Component injection with React.forwardRef\",\n  \"tags\": [\"react\", \"typescript\"],\n  \"image\": \"https://unsplash.com/photos/ZBstHWt9vLc\",\n  \"date\": \"2021-08-05T00:00:00.000Z\",\n  \"description\": \"Create wrapper components that can forward ref and infer their prop typings from the injectable wrapped component.\\n\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"There are two main patterns how to separate concerns into different components in React.\\nEither - given the concrete implementation to be wrapped - you create a new wrapped component as described in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://reactjs.org/docs/higher-order-components.html\"\n  }, \"React's Guide on Higher-Order Components\"), \" ...\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx\"\n  }, \"function createNewWrappedComponent(WrappedComponent) {\\n    return function Wrapper({title, children, ...others}) {\\n        return <WrappedComponent {...others}>\\n            <h3>{title}</h3>\\n            {children}\\n        </WrappedComponent>\\n    }\\n}\\nconst DivWithTitle = createNewWrappedComponent(\\\"div\\\")\\n\\nrender(<DivWithTitle title=\\\"foo\\\" className=\\\"bar\\\">\\n    baz\\n</DivWithTitle>)\\n\\n// results in\\n<div className=\\\"bar\\\"><h3>foo</h3>baz</div>\\n\")), mdx(\"p\", null, \"... or you accept a component as a prop - making the concrete implementation for the wrapped component injectable.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx\"\n  }, \"function Wrapper({WrappedComponent, title, children, ...others}) {\\n    return <WrappedComponent {...others}>\\n        <h3>{title}</h3>\\n        {children}\\n    </WrappedComponent>\\n}\\n\\nrender(<Wrapper WrappedComponent=\\\"div\\\" title=\\\"foo\\\" className=\\\"bar\\\">\\n    bar\\n</Wrapper>)\\n\\n// results in\\n<div className=\\\"bar\\\"><h3>foo</h3>baz</div>\\n\")), mdx(\"p\", null, \"When working with Typescript you want all component props to be typed - especially on reused code, no matter if you set the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"WrappedComponent\"), \" beforehand or per prop.\"), mdx(\"h2\", null, \"The problem\"), mdx(\"p\", null, \"One can infer props from the injected \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"WrappedComponent\"), \" like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"function Wrapper<\\n    T extends React.ElementType<{children?: React.ReactNode}>,\\n>({WrappedComponent, title, children, ...others}: {\\n    WrappedComponent: T\\n    title: string\\n} & Omit<\\n    React.ComponentPropsWithoutRef<T>,\\n    'WrappedComponent' // prevent type widening on this prop\\n    'title' // remove any other props we don't pass down\\n>): React.Element|null {\\n    /// ...\\n}\\n\")), mdx(\"h3\", null, mdx(\"inlineCode\", {\n    parentName: \"h3\"\n  }, \"Ref\"), \" is not a regular prop\"), mdx(\"p\", null, \"As \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://reactjs.org/docs/forwarding-refs.html#forwarding-refs-in-higher-order-components\"\n  }, \"React's Guide on Forwarding Refs\"), \" points out \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ref\"), \" it is not passed to regular components.\\nWhen one tries to have a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Wrapper\"), \" accept a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ref\"), \" because one wants it to mimic the behavior of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"WrappedComponent\"), \" so it can replace it in some context, it needs to be passed through \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.forwardRef\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx\"\n  }, \"const ForwardingWrapper = React.forwardRef(function Wrapper(\\n    {WrappedComponent, title, children, ...others},\\n    ref,\\n) {\\n    return <WrappedComponent {...others} ref={ref}>\\n        <h3>{title}</h3>\\n        {children}\\n    </WrappedComponent>\\n})\\n\")), mdx(\"p\", null, \"This \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ForwardingWrapper\"), \" infers its props and types from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Wrapper\"), \" but if our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Wrapper\"), \" is generically typed like described above this does not work and we end up with basically untyped props (and ref) on \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ForwardingWrapper\"), \".\\nAnd without knowing the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"WrappedComponent\"), \" beforehand one can not set the types for ref and props on \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.forwardRef<T, P>()\"), \".\"), mdx(\"h3\", null, \"Concrete types don't match generics\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Wrapper\"), \" as types above has a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"WrappedComponent\"), \" variable that is typed to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"T\"), \" which \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"extends React.Elements\"), \" - but it is not \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.Elements\"), \" because it could be a different subtype.\\n(If this does not ring a bell consider yourself lucky. I guess stumbling over \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ts2322\"), \" at some point and feeling stupid for not seeing the problem at first glance before Typescript yelled is part of the Typescript experience. ;) )\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"const element = <WrappedComponent // this is T\\n    // Props must match ComponentProps<T> & Attributes\\n    // But Typescript can not decide if this is the case\\n/>\\n\")), mdx(\"p\", null, \"Of course one could work around this per \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.createElement\"), \" because its props type defaults to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"any\"), \". But this kind of defeats the purpose.\"), mdx(\"h2\", null, \"The solution\"), mdx(\"p\", null, \"By typing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ForwardingWrapper\"), \" as a component function that infers its props (including ref) from one of its own props and using Typescript's inference from usage for the implementation of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Wrapper\"), \" we get the correct types both inside and outside our implementation.\"), mdx(\"p\", null, \"First we create generic types for props and ref:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"/**\\n * Infer the ForwardedRef from a component\\n */\\nexport type ComponentForwardRef<T extends React.ElementType>\\n    = React.ForwardedRef<React.ElementRef<T>>\\n\\n/**\\n * Properties of a wrapper component\\n */\\nexport type WrapperProps<\\n    /**\\n     * The property key for the component to be wrapped.\\n     */\\n    ComponentProp extends PropertyKey,\\n    /**\\n     * Additional properties for the wrapper.\\n     */\\n    AdditionalProps extends unknown,\\n    /**\\n     * The property key for properties passed down to the wrapped component.\\n     * `unknown` if properties of wrapper and wrapped are merged.\\n     */\\n    PropertiesProp extends PropertyKey | unknown,\\n    /**\\n     * The wrapped component.\\n     */\\n    Component extends React.ElementType,\\n> = {\\n    [k in ComponentProp]: Component\\n} & (\\n    PropertiesProp extends PropertyKey\\n    ? { [k in PropertiesProp]: React.ComponentProps<Component> }\\n    : Omit<React.ComponentProps<Component>, keyof AdditionalProps | ComponentProp>\\n) & AdditionalProps\\n\")), mdx(\"p\", null, \"We also prepare a generic type that properly describes \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ForwardingWrapper\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"export interface ForwardRefWrapper<\\n    ComponentProp extends PropertyKey,\\n    AdditionalProps extends unknown = unknown,\\n    PropertiesProp extends PropertyKey | unknown = unknown,\\n    /**\\n     * Base type for the wrapped component.\\n     */\\n    ComponentType extends React.ElementType = React.ElementType,\\n> extends OmitCallable<React.ForwardRefExoticComponent<any>> {\\n    <T extends ComponentType>(\\n        props: WrapperProps<ComponentProp, AdditionalProps, PropertiesProp, T>,\\n    ): React.ReactElement | null\\n}\\ntype OmitCallable<T> = Pick<T, keyof T>\\n\")), mdx(\"p\", null, \"With these types we are ready to write a utility function to create \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.ForwardRefExoticComponent\"), \" with our infered typing:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"function createForwardRefWrapper<\\n    ComponentProp extends PropertyKey,\\n    AdditionalProps extends unknown = unknown,\\n    PropertiesProp extends PropertyKey | unknown = unknown,\\n    ComponentType extends React.ElementType = React.ElementType,\\n>(\\n    wrapper: (\\n        props: WrapperProps<ComponentProp, AdditionalProps, PropertiesProp, ComponentType>,\\n        ref: ComponentForwardRef<ComponentType>\\n    ) => React.ReactElement | null,\\n): ForwardRefWrapper<ComponentProp, AdditionalProps, PropertiesProp, ComponentType> {\\n    return React.forwardRef(wrapper)\\n}\\n\")), mdx(\"p\", null, \"Now we can easily write a type safe wrapper with forwarded \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ref\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"const ForwardingWrapper = createForwardRefWrapper<\\n    'WrappedComponent',\\n    {title: string}\\n>(function Wrapper({WrappedComponent, title, children, ...others}, ref) {\\n    return (\\n        <WrappedComponent\\n            {...others}\\n            ref={ref}\\n        >\\n            <h3>{title}</h3>\\n            {children}\\n        </WrappedComponent>\\n    )\\n})\\n\")), mdx(\"p\", null, \"You can import \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createForwardRefWrapper\"), \" and the utility types from \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.npmjs.com/package/liform-util\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"liform-util\")), \".\"));\n}\n;\nMDXContent.isMDXComponent = true;","meta":{"title":"Component injection with React.forwardRef","date":"2021-08-05T00:00:00.000Z","tags":["react","typescript"],"description":"Create wrapper components that can forward ref and infer their prop typings from the injectable wrapped component.\n","image":"https://unsplash.com/photos/ZBstHWt9vLc"}}},"pageContext":{"id":"c1270b72-b839-500b-b92c-a979277d9cdc"}},"staticQueryHashes":["1466185270"]}