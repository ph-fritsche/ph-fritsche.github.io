{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/blog/post/render-prop-vs-component-prop","result":{"data":{"tags":{"edges":[{"node":{"path":"/blog/tag/gatsby"}},{"node":{"path":"/blog/tag/blog"}},{"node":{"path":"/blog/tag/php"}},{"node":{"path":"/blog/tag/symfony"}},{"node":{"path":"/blog/tag/pitch"}},{"node":{"path":"/blog/tag/react"}},{"node":{"path":"/blog/tag/testing"}},{"node":{"path":"/blog/tag/typescript"}}]},"site":{"siteMetadata":{"author":{"twitter":"ph_fritsche"}}},"mdx":{"body":"var _excluded = [\"components\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar _frontmatter = {\n  \"title\": \"Render prop and rerendering\",\n  \"tags\": [\"react\"],\n  \"image\": \"https://unsplash.com/photos/PdJGFcYk7g0\",\n  \"description\": \"Calling a render prop is similar to using it as a component. But it's not the same.\\n\",\n  \"date\": \"2022-08-16T00:00:00.000Z\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"I had always assumed that\"), mdx(\"pre\", {\n    parentName: \"blockquote\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx\"\n  }, \"const ComponentA = ({renderSomething}) => <div>{\\n   renderSomething({text: \\\"foo\\\"})\\n}</div>\\n\")), mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"and\"), mdx(\"pre\", {\n    parentName: \"blockquote\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx\"\n  }, \"const ComponentB = ({Something}) => <div>\\n   <Something text=\\\"foo\\\"/>\\n</div>\\n\")), mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"were functionally exactly the same, but they're not.\\nIt appears that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"renderSomething\"), \" is treated as the same component, i.e. mounts once,\\nwhereas \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Something\"), \" gets treated as a new component each time and will remount on each render.\"), mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"I'm a bit perplexed by this - reading the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://reactjs.org/docs/render-props.html#using-props-other-than-render\"\n  }, \"React render props documentation\"), \" doesn't mention anything about a naming convention, and infact seems to suggest that any property name is fine. \")), mdx(\"p\", null, \"I just stumbled over this and a confusion as described here, if you know the reason behind it, can seem silly and, as the missing hint in the React docs might suggest, not requiring any extra explanation.\\nBut the quoted bit reminded me that this difference can be rather subtle.\"), mdx(\"h2\", null, \"JSX element vs statement\"), mdx(\"p\", null, \"One of the biggest features of React is the simplicity of the syntax. There are no special operators, attributes or decorators. Everything in code for React is either the the simple \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://facebook.github.io/jsx/\"\n  }, \"JSX\"), \" syntax or good old vanilla JS.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"JSX is an XML-like syntax extension to ECMAScript without any defined semantics.\")), mdx(\"p\", null, \"If there is a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<Component \"), \" it starts a JSX block that ends at \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/>\"), \" or, if it isn't immediately closed, at the corresponding \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"</Component>\"), \". In the position of an XML attribute or child node curly brackets can enclose a part of JS - which can itself contain JSX again.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx\"\n  }, \"const element = <Component foo=\\\"some Text\\\" bar={1+2}>\\n    {'some child'}\\n    <div>some other child</div>\\n</Component>\\n\\n// translates to\\n\\nconst element = React.createElement(\\n    Component, // the element type\\n    {foo: 'someText', bar: 3} // the props that will be passed to the component\\n    'some child', // the children...\\n    React.createElement(\\n        'div', // this is a so called \\\"intrinsic\\\" element\\n        {}, // props are empty\\n        'some other child',\\n    )\\n)\\n\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.createElement\"), \" returns an object that can be mounted in the React tree.\"), mdx(\"h2\", null, \"A component is rendered\"), mdx(\"p\", null, \"If the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"element\"), \" object above is inserted as a node in the React tree, React calls \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://reactjs.org/docs/react-component.html#the-component-lifecycle\"\n  }, \"the lifecycle methods\"), \" on the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Component\"), \".\\nWhen the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"render\"), \" method - which in case of a functional component is the component - is called, the JS inside it is evaluated.\\nA valid component returns an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ReactElement\"), \" which is either an object like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"element\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"null\"), \". React proceeds to render that subtree.\"), mdx(\"h2\", null, \"Should an element be rerendered?\"), mdx(\"p\", null, \"When \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"element\"), \" is the result of a subsequent rendering,\\non the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"shouldComponentUpdate\"), \" step of the lifecycle it is determined\\nif executing the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"render\"), \" step is required again.\\nFor \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.PureComponent\"), \" and functional components this determined per shallow comparision of props and state.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"// props on 1st render\\n{foo: 'someText', bar: 3}\\n\\n// 2nd render - will skip the render\\n{foo: 'someText', bar: 3}\\n\\n// 3rd render - changing a value causes a rerender\\n{foo: 'someText', bar: 4}\\n\\n// 4th render - adding/removing props cause a rerender\\nconst anObject = {x: 1}\\n{foo: 'someText', bar: 4, baz: anObject}\\n\\n// 5th render - the comparison is shallow\\n{foo: 'someText', bar: 4, baz: anObject} // will not cause a rerender\\n{foo: 'someText', bar: 4, baz: {x: 1}} // will cause a rerender\\n\")), mdx(\"h2\", null, \"One more element in the tree\"), mdx(\"p\", null, \"For props to be compared as above, the element has to be considered the same.\\nAn element is the same if it's \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"key\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"type\"), \" (the component) are the same. Ergo if \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"key\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"type\"), \" is different, the object is considered to be a new element without a previous state or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"render\"), \" result.\"), mdx(\"p\", null, \"In JS two variables of type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"object\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"function\"), \" are equal if they are identical.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"() => {} == () => {} // false\\n\")), mdx(\"p\", null, \"As a consequence, if you create a callback function in your code, it is a different function each time although the results might be the same.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"function funcA() {\\n    return function funcB() {\\n        return 'foo'\\n    }\\n}\\n\\nfuncA == funcA // true\\nfuncA() == funcA() // false -- funcB\\u2081 != funcB\\u2082\\nfuncA()() == funcA()() // true -- \\\"foo\\\" == \\\"foo\\\"\\n\")), mdx(\"p\", null, \"This brings us back to the initial conundrum. If our two components - one treating the prop as a render callback and one treating is as a component - are passed a new function that does the same on a rerender, the resulting tree is different.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx\"\n  }, \"const ComponentA = ({renderSomething}) => <div>{\\n    renderSomething({text: \\\"foo\\\"})\\n}</div>\\n\\n// Using it like\\n<ComponentA renderSomething={({text}) => <p>{text}</p>}/>\\n// means\\nReact.createElement(\\n    ComponentA,\\n    {renderSomething: ({text}) => React.createElement(\\n        'p',\\n        {},\\n        text,\\n    )},\\n)\\n\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ComponentA\"), \" will always be rerendered here because the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"renderSomething\"), \" prop is different each time.\\nBut notice how the render result of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ComponentA\"), \" only contains elements with a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"type\"), \" that will be equal on rerenders.\", mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", \"Therefore rerendering of its children will be skipped.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx\"\n  }, \"ComponentA({renderSomething: ({text}) => React.createElement(\\n    'p',\\n    {},\\n    text,\\n)})\\n// results in\\nReact.createElement(\\n    'div',\\n    {},\\n    React.createElement(\\n        'p',\\n        {},\\n        'foo,\\n    )},\\n)\\n\")), mdx(\"p\", null, \"Now let's try to do the same with our other component:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx\"\n  }, \"const ComponentB = ({Something}) => <div><Something text=\\\"foo\\\"/></div>\\n\\n// Using it like\\n<ComponentB Something={({text}) => <p>{text}</p>}/>\\n// means\\nReact.createElement(\\n    ComponentB,\\n    {Something: ({text}) => React.createElement(\\n        'p',\\n        {},\\n        text,\\n    )},\\n)\\n\")), mdx(\"p\", null, \"Again our component will always be rerendered because the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Something\"), \" prop is different each time.\\nBut this time, the render result looks different.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx\"\n  }, \"ComponentB({Something: ({text}) => React.createElement(\\n    'p',\\n    {},\\n    text,\\n)})\\n// results in\\nReact.createElement(\\n    'div',\\n    {},\\n    React.createElement(\\n        // `Something` is used as an element type here\\n        ({text}) => React.createElement(\\n            'p',\\n            {},\\n            text,\\n        ),\\n        {text: 'foo'}\\n    )},\\n)\\n\")), mdx(\"h2\", null, \"The result\"), mdx(\"p\", null, \"When \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Something\"), \" is rendered, it will produce the same DOM tree as before.\\nBut because the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Something\"), \" element is considered to be a new element in the React tree, all its descendants are replaced.\", mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", \"This means they won't retain their state and the resulting DOM elements will be new elements, i.e. they won't have e.g. focus or a selection in the browser even if their look-alike predecessor had it.\"));\n}\n;\nMDXContent.isMDXComponent = true;","meta":{"title":"Render prop and rerendering","date":"2022-08-16T00:00:00.000Z","tags":["react"],"description":"Calling a render prop is similar to using it as a component. But it's not the same.\n","image":"https://unsplash.com/photos/PdJGFcYk7g0"}}},"pageContext":{"id":"4ba2508c-8662-5cdd-9e96-c30c655671f3"}},"staticQueryHashes":["1466185270"]}